package main

import (
	"log"
	"net"
	"os"
	"time"
)

const udpPort = 30000

const defaultPollingInterval = 4 * time.Second

// Simple Go replacement for the poller executable
// This sends SLIP topology messages to discover pool devices

func main() {
	log.Println("Starting Go poller replacement...")

	// Allow polling interval to be set via command-line flag
	interval := flag.Duration("interval", defaultPollingInterval, "Polling interval (e.g. 4s, 2m)")
	flag.Parse()

	// Check if we're running as root (required for SLIP operations)
	if os.Geteuid() != 0 {
		log.Fatal("This program must be run as root (use sudo)")
	}

	// Check if sl0 interface exists
	iface, err := net.InterfaceByName("sl0")
	if err != nil {
		log.Printf("Warning: sl0 interface not found: %v", err)
		log.Printf("This is normal if not running on a Raspberry Pi with SLIP configured")
		// Continue anyway for testing purposes
	} else {
		log.Printf("Found SLIP interface: %s", iface.Name)
	}

	// Main polling loop - send topology messages at configured interval
	ticker := time.NewTicker(*interval)
	defer ticker.Stop()

	log.Printf("Starting topology message loop (every %s)...", interval.String())

	for {
		select {
		case <-ticker.C:
			sendTopologyMessages()
		}
	}
}

func sendTopologyMessages() {
	log.Println("=== Starting Token-Passing Polling Cycle ===")

	// PHASE 1: Send wake-up sequence (6 broadcast messages with fixed key IPs)
	// This tells all devices "polling cycle starting, prepare to announce via MQTT"
	sendWakeupSequence()

	// Small delay to let devices process the wake-up sequence
	time.Sleep(100 * time.Millisecond)

	// PHASE 2: Send token assignment (broadcast with winning device IP as payload)
	// For now, cycle through known device IPs as token holders
	sendTokenAssignment()

	log.Println("=== Polling Cycle Complete ===")
}

func sendWakeupSequence() {
	log.Println("Phase 1: Sending wake-up key sequence (6 messages)...")

	// These are the exact fixed IP addresses from the original poller
	// Acting as a "magic key sequence" to wake up devices
	keySequenceIPs := []string{
		"169.254.221.176", // Key 1
		"169.254.250.76",  // Key 2
		"169.254.245.193", // Key 3
		"169.254.11.39",   // Key 4
		"169.254.221.176", // Key 5 (repeat for emphasis)
		"169.254.250.76",  // Key 6 (repeat for emphasis)
	}

	for i, keyIP := range keySequenceIPs {
		sendUDPMessage(keyIP, []byte{169, 254, 255, 255}) // Broadcast payload
		log.Printf("Sent wake-up key %d/6: %s", i+1, keyIP)
		time.Sleep(50 * time.Millisecond) // Brief delay between key messages
	}

	log.Println("Wake-up sequence complete - devices should now announce via MQTT")
}

func sendTokenAssignment() {
	log.Println("Phase 2: Assigning RS485 bus token...")

	// Known device IPs that might be on the network
	// In a real implementation, this would be dynamic based on discovered devices
	candidateDevices := []string{
		"169.254.20.84", // Common sanitizer IP
		"169.254.20.85", // Another potential device
		"169.254.1.100", // VSP or other device
	}

	// For now, just assign token to first candidate
	// Real implementation would track which devices responded to wake-up
	tokenHolder := candidateDevices[0]

	// Convert IP to 4-byte payload for UDP message
	ip := net.ParseIP(tokenHolder).To4()
	if ip != nil {
		sendUDPMessage("169.254.255.255", ip) // Broadcast the token assignment
		log.Printf("Token assigned to device: %s", tokenHolder)
		log.Printf("Device %s now has exclusive RS485 bus access", tokenHolder)

func sendUDPMessage(destination string, payload []byte) {
	// Send UDP message to specified destination on the defined UDP port
	// This implements the original C poller's UDP protocol

	target := net.JoinHostPort(destination, fmt.Sprintf("%d", udpPort))
	conn, err := net.Dial("udp", target)
	if err != nil {
		log.Printf("Failed to send UDP message to %s: %v", target, err)
		return
	}
	defer conn.Close()
	target := destination + ":30000"
	conn, err := net.Dial("udp", target)
	if err != nil {
		log.Printf("Failed to send UDP message to %s: %v", target, err)
		return
	}
	defer conn.Close()

	// Send the message payload
	_, err = conn.Write(payload)
	if err != nil {
		log.Printf("Error sending UDP message to %s: %v", target, err)
	if len(payload) >= 4 {
		log.Printf("UDP -> %s: [%d.%d.%d.%d]", target, payload[0], payload[1], payload[2], payload[3])
	} else {
		log.Printf("UDP -> %s: [payload too short: %v]", target, payload)
	}
	}

	// Log details for debugging
	log.Printf("UDP -> %s: [%d.%d.%d.%d]", target, payload[0], payload[1], payload[2], payload[3])
}
