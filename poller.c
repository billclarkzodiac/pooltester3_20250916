#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <time.h>
#include <string.h>
#include <errno.h>
#include <netinet/in.h>
#include <linux/if_ether.h>
#include <linux/filter.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <net/ethernet.h> /* the L2 protocols */
#include <fcntl.h> 
#include <termios.h>
#include <sys/mman.h>
#include <signal.h>

#define IDLE_POLL 50
#define MAX_RESPONSE_TIME 200

// IOCTL for custom SLIP kernel module, must match that module code:
#define REG_CURRENT_TASK _IOW('a','a',int32_t*)

int IdleTime = 0;
int *Resp;
int *End;
int *Nga;
/* msleep(): Sleep for the requested number of milliseconds. */
int msleep(long msec)
{
    struct timespec ts;
    int res;

    if (msec < 0)
    {
        errno = EINVAL;
        return -1;
    }

    ts.tv_sec = msec / 1000;
    ts.tv_nsec = (msec % 1000) * 1000000;

    do {
        res = nanosleep(&ts, &ts);
    } while (res && errno == EINTR);

    return res;
}

int filter();
int poll();

int main(int argc, char *argv[])
{
  	Resp = (int*) mmap(NULL, sizeof (int) , PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*Resp = 0;

  	End = (int*) mmap(NULL, sizeof (int) , PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*End = 0;

  	Nga = (int*) mmap(NULL, sizeof (int) , PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*Nga = 0;

	if(fork() == 0)
	{
	// child process, filter actions
	poll();
	}
	else
	{
	// parent, poll
	filter();
	}
}

int filter()
{
int sock;	// filter socket
int n;
static char buffer[2048];
struct ifreq ifr;
struct sockaddr_ll interfaceAddr;
struct packet_mreq mreq;
struct sockaddr_ll addr;
socklen_t addr_len = sizeof(addr);

if ((sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0) // or maybe ETH_P_IP?
{
    perror("socket");
    _exit(1);
}

memset(&interfaceAddr,0,sizeof(interfaceAddr));
memset(&ifr,0,sizeof(ifr));
memset(&mreq,0,sizeof(mreq));

memcpy(&ifr.ifr_name,"sl0",IFNAMSIZ);
ioctl(sock,SIOCGIFINDEX,&ifr);

interfaceAddr.sll_ifindex = ifr.ifr_ifindex;
interfaceAddr.sll_family = AF_PACKET;

if (bind(sock, (struct sockaddr *)&interfaceAddr,sizeof(interfaceAddr)) < 0)
{
    perror("setsockopt bind device");
    close(sock);
    _exit(1);
}
#ifdef PROMISCUOUS_ONE_WAY
mreq.mr_ifindex = ifr.ifr_ifindex;
mreq.mr_type = PACKET_MR_PROMISC;
mreq.mr_alen = 6;

if (setsockopt(sock,SOL_PACKET,PACKET_ADD_MEMBERSHIP, (void*)&mreq,(socklen_t)sizeof(mreq)) < 0)
{
    perror("setsockopt promiscuous");
    close(sock);
    _exit(1);
}
#endif

    struct ifreq ethreq;
    strncpy(ethreq.ifr_name, "sl0", IF_NAMESIZE);
    if (ioctl(sock, SIOCGIFFLAGS, &ethreq) == -1) {
        perror("ioctl");
        close(sock);
        _exit(1);
    }
    ethreq.ifr_flags |= IFF_PROMISC;
    if (ioctl(sock, SIOCSIFFLAGS, &ethreq) == -1) {
        perror("ioctl");
        close(sock);
        _exit(1);
    }

#ifdef OLD_WAY
// bind to slip interface only
const char *opt;
opt = "sl0";
if (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, opt, strlen(opt) + 1) < 0) {
    perror("setsockopt bind device");
    close(sock);
    _exit(1);
}

// attach the filter to the socket if wanted...since this filter passes all it isn't needed
// the filter code is generated by running: sudo tcpdump -dd ip
struct sock_filter BPF_code[] = {
{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 1, 0x00000800 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },
}; 
struct sock_fprog Filter;
// error prone code, .len field should be consistent with the real length of the filter code array
Filter.len = sizeof(BPF_code)/sizeof(BPF_code[0]); 
Filter.filter = BPF_code;

//if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &Filter, sizeof(Filter)) < 0) {
//    perror("setsockopt attach filter");
//    close(sock);
//    _exit(1);
//} 

#endif

struct timeval tv;
tv.tv_sec = 5;
tv.tv_usec = 1000;
setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv);

while(1)
{
 n = recvfrom(sock, buffer, 2048, 0, (struct sockaddr*)&addr, &addr_len);
 if(n > 0)
 {
	if(addr.sll_pkttype == PACKET_OUTGOING)
	{
//	printf("OUT:\n");	
	}
	else 
	{
//	*End = 1;	// flag end of response
//	printf("Slip packet Rx:\n");	
        IdleTime = 0;
	}
	//printf("FILT(%d): %2.2X %2.2X %2.2X %2.2X\n", n, buffer[0], buffer[1], buffer[2], buffer[3]);
 }
 else
 {
  IdleTime++;
 }
}

return(0);
}

void legacy_poll()
{
int fd;
struct termios port;
// open port
char *portname = "/dev/ttyS0";
speed_t ospeed, ispeed;
static unsigned char enq[] = {0x10, 0x02, 0x78, 0x00, 0x8A, 0x10, 0x03}; 
int i, res;
int sock_r;
static struct sockaddr_ll sadr_ll;
int ifindex;
int number;


// slip interface index
ifindex = if_nametoindex("sl0");
	
// raw socket 
sock_r=socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL));
if(sock_r < 0)
{
	printf("Error on raw sock.");
}

sadr_ll.sll_ifindex = ifindex; // index of interface
sadr_ll.sll_protocol  = htons(ETH_P_ALL);
sadr_ll.sll_family    = AF_PACKET;

fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC);
if(fd >= 0)
{
	// stop TTY so no SLIP traffic goes out
	number = 100;
	ioctl(fd, REG_CURRENT_TASK,(int32_t*) &number);	// tell custom SLIP driver stop tty

	// not exclusive
	ioctl(fd, TIOCEXCL, &res);
	// get current baud rate
	tcgetattr(fd, &port);
	ospeed = cfgetospeed(&port); 
	ispeed = cfgetispeed(&port); 
//printf("Pre speeds %u %u\n", ospeed, ispeed);
	// change to 9600 bps
	cfsetospeed(&port, B9600);
	cfsetispeed(&port, B9600);
        tcsetattr(fd, TCSANOW, &port);
// transmit
	number = 101;
	ioctl(fd, REG_CURRENT_TASK,(int32_t*) &number);	// tell custom SLIP driver start tty
	i = sendto(sock_r,enq,7,0,(const struct sockaddr*)&sadr_ll,sizeof(struct sockaddr_ll));
//	ioctl(fd, 0x5555, &enq);
//	i = 7;
	// re-stop after our transmit, which internally starts TX
	number = 100;
	ioctl(fd, REG_CURRENT_TASK,(int32_t*) &number);	// tell custom SLIP driver stop tty
	if(i<0)
	{
	printf("error in sending....ret=%d....errno=%d\n",i,errno);
	}       	

if(i != 7)
{
	printf("Write %d errno: %d\n", i, errno);
}
	//tcdrain(fd); // Wait until transmission ends
	//tcflush(fd, TCOFLUSH); // Clear write buffer	
printf("p");
// receive
	msleep(100);

	// restore baud rate
	i = cfsetospeed(&port, ospeed);
//printf("Set ospeed ret %d\n", i);
	i = cfsetispeed(&port, ispeed);
//printf("Set ispeed ret %d\n", i);
        tcsetattr(fd, TCSANOW, &port);
	ospeed = cfgetospeed(&port); 
	ispeed = cfgetispeed(&port); 
//printf("\nPost speeds %u %u\n", ospeed, ispeed);
	close(fd);
}
else
{
	printf("Failed to open serial port %d\n", fd);
}
close(sock_r);
}

void sig_event_handler(int n, siginfo_t *info, void *unused)
{
int check;
    if (n == 44 && *Nga == 1) {
        check = info->si_int;
	if(check == 0)	//	0xC0 at start of SLIP frame
		*Resp = 1;
	else
		*End = 1;	// 0xC0 at end of slip frame

//        printf ("Signal from kernel : %u\n", check);
    }
}
int poll()
{
int bcast_sock;
#define BROADCAST_PORT 30000u
struct sockaddr_in s;
char mess[8];
int i;
int idle;
int fd;
char *portname = "/dev/ttyS0";
struct termios port;
struct sigaction act;
int number;

/* install custom signal handler */
sigemptyset(&act.sa_mask);
act.sa_flags = (SA_SIGINFO | SA_RESTART);
act.sa_sigaction = sig_event_handler;
sigaction(44, &act, NULL);

// change SLIP baud rate to desired baud rate
fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC);
number = 0;
ioctl(fd, REG_CURRENT_TASK,(int32_t*) &number);	// tell driver we are the task to signal
tcgetattr(fd, &port);
cfsetospeed(&port, B115200);
cfsetispeed(&port, B115200);
tcsetattr(fd, TCSANOW, &port);


bcast_sock = socket(AF_INET, SOCK_DGRAM, 0);
int broadcastEnable=1;
int ret=setsockopt(bcast_sock, SOL_SOCKET, SO_BROADCAST, &broadcastEnable, sizeof(broadcastEnable));

memset(&s, '\0', sizeof(struct sockaddr_in));
s.sin_family = AF_INET;
s.sin_port = htons(BROADCAST_PORT);
s.sin_addr.s_addr = inet_addr("169.254.255.255");
//s.sin_addr.s_addr = INADDR_BROADCAST;

ioctl(fd, REG_CURRENT_TASK,(int32_t*) &number);	// tell driver start tty 

while(1)
{
// start TTY
number = 101;
ioctl(fd, REG_CURRENT_TASK,(int32_t*) &number);	// tell custom SLIP driver start tty 

 mess[0] = 169; 
 mess[1] = 254; 
 mess[2] = 221; 
 mess[3] = 176; 
 *Resp = 0;
 *End = 0;
 *Nga = 1;
 sendto(bcast_sock, mess, 4, 0, (struct sockaddr *)&s, sizeof(struct sockaddr_in));
        tcdrain(fd); // Wait until transmission ends
        tcflush(fd, TCOFLUSH); // Clear write buffer
printf("1");fflush(stdout);
 idle = 0;
 while(*Resp == 0 ? idle < IDLE_POLL : idle < MAX_RESPONSE_TIME)
 {
  msleep(1);
  idle++;
  if(*End != 0 && *Resp != 0)break;
 }
  if(*Resp == 1)
	printf("X"),fflush(stdout);

 mess[0] = 169; 
 mess[1] = 254; 
 mess[2] = 250; 
 mess[3] = 76; 
 *Resp = 0;
 *End = 0;
 sendto(bcast_sock, mess, 4, 0, (struct sockaddr *)&s, sizeof(struct sockaddr_in));
        tcdrain(fd); // Wait until transmission ends
        tcflush(fd, TCOFLUSH); // Clear write buffer
printf("2");fflush(stdout);
 idle = 0;
 while(*Resp == 0 ? idle < IDLE_POLL : idle < MAX_RESPONSE_TIME)
 {
  msleep(1);
  idle++;
  if(*End != 0 && *Resp != 0)break;
 }
  if(*Resp == 1)
	printf("X"),fflush(stdout);

// 169.254.245.193

 mess[0] = 169;
 mess[1] = 254;
 mess[2] = 245;
 mess[3] = 193;
 *Resp = 0;
 *End = 0;
 sendto(bcast_sock, mess, 4, 0, (struct sockaddr *)&s, sizeof(struct sockaddr_in));
        tcdrain(fd); // Wait until transmission ends
        tcflush(fd, TCOFLUSH); // Clear write buffer
printf("3");fflush(stdout);
 idle = 0;
 while(*Resp == 0 ? idle < IDLE_POLL : idle < MAX_RESPONSE_TIME)
 {
  msleep(1);
  idle++;
  if(*End != 0 && *Resp != 0)break;
 }
  if(*Resp == 1)
	printf("X"),fflush(stdout);

// 169.254.11.39
 mess[0] = 169;
 mess[1] = 254;
 mess[2] = 11;
 mess[3] = 39;
 *Resp = 0;
 *End = 0;
 sendto(bcast_sock, mess, 4, 0, (struct sockaddr *)&s, sizeof(struct sockaddr_in));
        tcdrain(fd); // Wait until transmission ends
        tcflush(fd, TCOFLUSH); // Clear write buffer
printf("4");fflush(stdout);
 idle = 0;
 while(*Resp == 0 ? idle < IDLE_POLL : idle < MAX_RESPONSE_TIME)
 {
  msleep(1);
  idle++;
  if(*End != 0 && *Resp != 0)break;
 }
  if(*Resp == 1)
	printf("X"),fflush(stdout);

tcdrain(fd); // Wait until transmission ends
tcflush(fd, TCOFLUSH); // Clear write buffer	

 *Nga = 0;

 legacy_poll();
}

return(0);
}

