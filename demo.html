<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NgaSim Pool Controller Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .device-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            border-left: 4px solid #3498db;
        }

        .device-card.online {
            border-left-color: #00cc66;
        }

        .device-card.offline {
            border-left-color: #999999;
            opacity: 0.7;
        }

        .device-card.error {
            border-left-color: #ff0000;
            animation: errorFlash 1s infinite;
        }

        @keyframes errorFlash {

            0%,
            50% {
                background-color: white;
            }

            25%,
            75% {
                background-color: #ffe6e6;
            }
        }

        .device-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .device-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .device-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .status-online {
            background-color: #00cc66;
            color: white;
        }

        .status-offline {
            background-color: #999999;
            color: white;
        }

        .widget {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .widget-label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #34495e;
        }

        .widget-value {
            font-size: 1.1em;
            color: #2c3e50;
        }

        .digital-display {
            font-family: 'Courier New', monospace;
            background: black;
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 4px;
            text-align: center;
            font-size: 1.2em;
        }

        .toggle-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-button.on {
            background-color: #00cc66;
            color: white;
        }

        .toggle-button.off {
            background-color: #aaaaaa;
            color: white;
        }

        .toggle-button.error {
            background-color: #ff0000;
            color: white;
            animation: errorFlash 1s infinite;
        }

        .dial-gauge {
            width: 120px;
            height: 120px;
            border: 4px solid #3498db;
            border-radius: 50%;
            position: relative;
            margin: 10px auto;
        }

        .dial-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 50px;
            background: #e74c3c;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            transition: transform 0.5s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .error-msg {
            background-color: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .info-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ccc;
            display: inline-block;
        }

        .rgbw-display {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .rgbw-channel {
            text-align: center;
            padding: 5px;
            background: #ecf0f1;
            border-radius: 4px;
            min-width: 40px;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>NgaSim Pool Controller Dashboard</h1>
        <p>Real-time device monitoring and control</p>
    </div>

    <div id="loading" class="loading">
        <h3>Loading dashboard configuration and devices...</h3>
    </div>

    <div id="error" class="error-msg" style="display: none;"></div>

    <div id="dashboard" class="dashboard" style="display: none;"></div>

    <div id="ui-spec-info" class="info-section" style="display: none;">
        <h3>UI Specification Details</h3>
        <div id="spec-details"></div>
    </div>

    <script>
        let uiSpec = null;
        let devices = {};

        // Fetch UI specification from TOML endpoint
        async function loadUISpec() {
            try {
                const response = await fetch('/api/ui/spec');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                uiSpec = await response.json();
                console.log('UI Spec loaded:', uiSpec);
                return true;
            } catch (error) {
                console.error('Failed to load UI spec:', error);
                showError('Failed to load UI specification: ' + error.message);
                return false;
            }
        }

        // Fetch device data
        async function loadDevices() {
            try {
                const response = await fetch('/api/devices');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const deviceData = await response.json();
                devices = deviceData.devices || {};
                console.log('Devices loaded:', devices);
                return true;
            } catch (error) {
                console.error('Failed to load devices:', error);
                showError('Failed to load device data: ' + error.message);
                return false;
            }
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Show dashboard
        function showDashboard() {
            document.getElementById('dashboard').style.display = 'grid';
            document.getElementById('ui-spec-info').style.display = 'block';
        }

        // Get device type configuration
        function getDeviceTypeConfig(category) {
            if (!uiSpec || !uiSpec.DeviceTypes) return null;
            return uiSpec.DeviceTypes.find(type => type.Category === category);
        }

        // Render a widget based on its configuration and device data
        function renderWidget(widget, deviceData, deviceTypeConfig) {
            const widgetDiv = document.createElement('div');
            widgetDiv.className = 'widget';

            const label = document.createElement('div');
            label.className = 'widget-label';
            label.textContent = widget.Label || widget.ID;
            widgetDiv.appendChild(label);

            const valueDiv = document.createElement('div');
            valueDiv.className = 'widget-value';

            // Get the actual data value (this is simplified - real implementation would map to telemetry fields)
            let value = 'N/A';
            let status = 'unknown';

            // Simplified data mapping based on widget ID and device type
            if (deviceData && deviceData.telemetry) {
                switch (widget.ID) {
                    case 'ppm_display':
                        value = deviceData.telemetry.ppm_salt || 0;
                        break;
                    case 'power_gauge':
                        value = deviceData.telemetry.percentage_output || 0;
                        break;
                    case 'power_button':
                        status = deviceData.telemetry.percentage_output > 0 ? 'on' : 'off';
                        break;
                    case 'rpm_display':
                        value = deviceData.telemetry.rpm || '----';
                        break;
                    case 'heater_state':
                    case 'hp_state':
                        value = deviceData.telemetry.heating_status || 'OFF';
                        break;
                    case 'rgbw_values':
                        const r = deviceData.telemetry.red || 0;
                        const g = deviceData.telemetry.green || 0;
                        const b = deviceData.telemetry.blue || 0;
                        const w = deviceData.telemetry.white || 0;
                        value = `R:${r} G:${g} B:${b} W:${w}`;
                        break;
                }
            }

            // Render based on widget type
            switch (widget.Type) {
                case 'digital_display':
                    valueDiv.className += ' digital-display';
                    if (widget.Digits && typeof value === 'number') {
                        valueDiv.textContent = value.toString().padStart(widget.Digits, '0');
                    } else {
                        valueDiv.textContent = value.toString();
                    }
                    break;

                case 'toggle_button':
                    const button = document.createElement('button');
                    button.className = 'toggle-button ' + status;
                    button.textContent = status.toUpperCase();
                    button.onclick = () => alert('Button clicked! (Control not implemented)');
                    valueDiv.appendChild(button);
                    break;

                case 'dial':
                    const gauge = document.createElement('div');
                    gauge.className = 'dial-gauge';
                    const needle = document.createElement('div');
                    needle.className = 'dial-needle';
                    // Rotate needle based on value (simplified)
                    const angle = (value / 100) * 270 - 135; // Map 0-100% to dial position
                    needle.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                    gauge.appendChild(needle);
                    valueDiv.appendChild(gauge);

                    const gaugeLabel = document.createElement('div');
                    gaugeLabel.textContent = `${value}%`;
                    gaugeLabel.style.textAlign = 'center';
                    valueDiv.appendChild(gaugeLabel);
                    break;

                case 'quad_display':
                    const rgbwDiv = document.createElement('div');
                    rgbwDiv.className = 'rgbw-display';
                    widget.Channels.forEach((channel, index) => {
                        const channelDiv = document.createElement('div');
                        channelDiv.className = 'rgbw-channel';
                        channelDiv.innerHTML = `<div>${channel}</div><div>${Math.floor(Math.random() * 256)}</div>`;
                        rgbwDiv.appendChild(channelDiv);
                    });
                    valueDiv.appendChild(rgbwDiv);
                    break;

                case 'color_lamp':
                    const colorPreview = document.createElement('div');
                    colorPreview.className = 'color-preview';
                    colorPreview.style.backgroundColor = '#ff6600'; // Simplified color
                    valueDiv.appendChild(colorPreview);
                    break;

                default:
                    valueDiv.textContent = value.toString();
            }

            widgetDiv.appendChild(valueDiv);
            return widgetDiv;
        }

        // Render a single device card
        function renderDeviceCard(deviceId, deviceData) {
            const deviceTypeConfig = getDeviceTypeConfig(deviceData.category);
            if (!deviceTypeConfig) {
                console.warn(`No UI config found for device category: ${deviceData.category}`);
                return null;
            }

            const card = document.createElement('div');
            card.className = 'device-card';

            // Determine online status (simplified)
            const isOnline = deviceData.last_seen && (Date.now() - new Date(deviceData.last_seen).getTime()) < 60000;
            card.classList.add(isOnline ? 'online' : 'offline');

            // Device header
            const header = document.createElement('div');
            header.className = 'device-header';

            const nameDiv = document.createElement('div');
            nameDiv.className = 'device-name';
            nameDiv.textContent = `${deviceTypeConfig.Name} (${deviceId.slice(-4)})`;

            const statusDiv = document.createElement('div');
            statusDiv.className = `device-status status-${isOnline ? 'online' : 'offline'}`;
            statusDiv.textContent = isOnline ? 'ONLINE' : 'OFFLINE';

            header.appendChild(nameDiv);
            header.appendChild(statusDiv);
            card.appendChild(header);

            // Device info
            const infoDiv = document.createElement('div');
            infoDiv.innerHTML = `
                <strong>Product:</strong> ${deviceData.product_name || 'Unknown'}<br>
                <strong>Model:</strong> ${deviceData.model_id || 'Unknown'}<br>
                <strong>Firmware:</strong> ${deviceData.firmware_version || 'Unknown'}
            `;
            card.appendChild(infoDiv);

            // Render widgets
            if (deviceTypeConfig.Widgets) {
                deviceTypeConfig.Widgets.forEach(widget => {
                    const widgetElement = renderWidget(widget, deviceData, deviceTypeConfig);
                    card.appendChild(widgetElement);
                });
            }

            return card;
        }

        // Render the complete dashboard
        function renderDashboard() {
            const dashboardDiv = document.getElementById('dashboard');
            dashboardDiv.innerHTML = '';

            // Render device cards
            Object.entries(devices).forEach(([deviceId, deviceData]) => {
                const card = renderDeviceCard(deviceId, deviceData);
                if (card) {
                    dashboardDiv.appendChild(card);
                }
            });

            // Show UI spec info
            const specDetails = document.getElementById('spec-details');
            specDetails.innerHTML = `
                <p><strong>Title:</strong> ${uiSpec.Meta.Title}</p>
                <p><strong>Version:</strong> ${uiSpec.Meta.Version}</p>
                <p><strong>Dashboard View:</strong> ${uiSpec.Dashboard.Visual.View}</p>
                <p><strong>Device Types:</strong> ${uiSpec.DeviceTypes.length} configured</p>
                <p><strong>Online Color:</strong> <span style="color: ${uiSpec.Dashboard.Visual.OnlineColor}">${uiSpec.Dashboard.Visual.OnlineColor}</span></p>
                <p><strong>Offline Color:</strong> <span style="color: ${uiSpec.Dashboard.Visual.OfflineColor}">${uiSpec.Dashboard.Visual.OfflineColor}</span></p>
            `;
        }

        // Initialize the dashboard
        async function init() {
            console.log('Initializing dashboard...');

            const specLoaded = await loadUISpec();
            const devicesLoaded = await loadDevices();

            hideLoading();

            if (specLoaded && devicesLoaded) {
                renderDashboard();
                showDashboard();

                // Refresh device data every 5 seconds
                setInterval(async () => {
                    await loadDevices();
                    renderDashboard();
                }, 5000);

                console.log('Dashboard initialized successfully');
            } else {
                showError('Failed to initialize dashboard - check console for details');
            }
        }

        // Start the application
        init();
    </script>
</body>

</html>